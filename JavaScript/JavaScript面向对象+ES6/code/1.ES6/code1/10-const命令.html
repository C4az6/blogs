<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 1.const声明一个只读的常量，一旦声明之后不能改变!
    //  const PI =3.1415;
    //  console.log(PI)  // 3.1415
    //  PI = 3;  // Assignment to constant variable.


    // 2.const声明的常量必须马上赋值，不能等到声明完了以后再赋值
    // const name;
    // name = 'Alex';   // 报错： Missing initializer in const declaration


    // 3.const作用域与let命令相同，只在声明所在的块级作用域内有效
    // if(true) {
    //   const NAME = 'alex'
    //   console.log(NAME)   // alex
    // }
    // console.log(NAME)   // NAME is not defined

    // 4.常量中保存复杂数据类型的问题
    // const foo = {};
    // // 为foo添加一个属性，可以成功
    // foo.prop = 123;
    // foo.prop = 'alex'
    // // 将foo指向另一个对象则会报错
    // foo = {};   // Assignment to constant variable.
    // 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。

    // 保存数组为常量
    // const a = [];
    // a.push(1,2,3,4);    // 不会报错
    // a.length = 0;   // 不会报错
    // a = ['newData'];  // 报错  Assignment to constant variable.
    //上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。

    // 5.冻结复杂类型数据
    // 'use strict';
    // const obj = Object.freeze({name: 'alex'});
    // 常规模式时，下面一行不起作用；
    // 严格模式时，该行会报错
    // obj.gender = '男';
    // 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。

    // Object.freeze无法冻结多层嵌套的对象中的属性
    // const array = Object.freeze([{name: 'alex'}])
    // array[0]['gender'] = '男'
    // console.log(array)

    // 6.递归方式冻结复杂数据类型嵌套中的属性
    var constantize = (obj) => {
      // 冻结对象
      Object.freeze(obj);
      Object.keys(obj).forEach((key, i) => {
        // 判断是否为object类型
        if (typeof obj[key] === 'object') {
          // 递归调用
          constantize(obj[key])
        }
      })
      return obj;
    }

    const array = constantize([{
      name: 'alex'
    }]);
    console.log(array)

    /* 
      总结：
      1.const声明一个只读的常量，一旦声明后不能改变。
      2.const声明的常量必须马上赋值，不能等到声明完了之后再赋值。
      3.const作用域、变量提升、暂存性死区、不可重复声明的问题上与let命令一致。
     */
  </script>
</body>

</html>