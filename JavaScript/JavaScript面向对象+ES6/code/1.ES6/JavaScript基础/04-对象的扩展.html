<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    /* 
      对象的扩展
     */

    /* 对象的简洁表示法 */

    // let a = 1;
    // const obj = {
    //   a: a   // 原始的写法
    // }

    // const obj = {a};    // es6中支持了如果对象的key和value一致的情况下可以只写一个
    // console.log(obj);

    // const obj = {
    //   fn: function () {
    //     console.log(1);
    //   },
    //   fn2() {   // 对象中的函数简写
    //     console.log(2);
    //   }
    // }

    // obj.fn(); // 1
    // obj.fn2(); // 2


    /* 
      Object.is()
        此方法用来判断2个数据是否一样，长的一样就是true，否则就是false；
        MDN：该方法判断两个值是否为同一个值。如果满足以下条件则两个值相等:
          1.都是undefined
          2.都是null
          3.都是true或false
          4.都是相同长度的字符串且相同字符按相同顺序排列
          5.都是相同对象（意味着每个对象由同一个引用），就是指向的是同一块内存地址，你的属性变了我的也会跟着变
          6.都是数字且：
            1.都是+0
            2.都是-0
            3.都是NaN
            4.活都是非零而且非NaN且为同一个值
        Object.is方法与 == 运算符不同；==运算符在判断相等前对两边的变量（如果它们不是统一类型）进行强制转换（这种行为的结果会将 "" == false 判断为true），
        而Object.is不会强制转换两边的值。

        Object.js方法与 === 运算符也不相同。 === 运算符（也包括==运算符）将数字-0和+0视为相等，而将Number.NaN与NaN视为不相等。
     */

    // console.log(Object.is(NaN, NaN)); // true  因为长的一样，但是NaN是和任何数据都不想等的!!!
    // console.log(NaN === NaN);   // false
    // console.log(Object.is(+0, -0));  // false，实际是一样的，但是长的不一样，所以返回false
    // console.log(+0 === -0);   // true


    /*
     Object.assign() 
        用于对象的合并，将源对象的所有可枚举属性，复制到目标对象。
        注意：该方法会覆盖之前相同key的值
    */
    let obj1 = {
      a: 1
    };
    let obj2 = {
      a: 2,
      b: 3
    };
    let obj3 = {
      c: 'alex'
    }
    // Object.assign(obj1, obj2, obj3);
    // console.log(obj1);    // {a: 2, b: 3, c: "alex"}
  </script>
</body>

</html>